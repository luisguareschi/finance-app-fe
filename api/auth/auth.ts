// @ts-nocheck

/**
 * Auto Generated by orval
 * Do not edit manually.
 * BaseApp Backend API
 * API para el sistema de BaseApp Backend
 */

import { useMutation } from "@tanstack/react-query";
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";
import type {
  EmailTokenObtain,
  TokenRefresh,
  UserRegistration,
} from "../baseAppBackendAPI.schemas";
import { customAxios } from "../../lib/axiosInstance";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 */
export const authLoginCreate = (
  emailTokenObtain: EmailTokenObtain,
  signal?: AbortSignal,
) => {
  return customAxios<EmailTokenObtain>({
    url: `/api/auth/login/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: emailTokenObtain,
    signal,
  });
};

export const getAuthLoginCreateMutationOptions = <
  TData = Awaited<ReturnType<typeof authLoginCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: EmailTokenObtain },
    TContext
  >;
}) => {
  const mutationKey = ["authLoginCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLoginCreate>>,
    { data: EmailTokenObtain }
  > = (props) => {
    const { data } = props ?? {};

    return authLoginCreate(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: EmailTokenObtain },
    TContext
  >;
};

export type AuthLoginCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLoginCreate>>
>;
export type AuthLoginCreateMutationBody = EmailTokenObtain;
export type AuthLoginCreateMutationError = unknown;

export const useAuthLoginCreate = <
  TData = Awaited<ReturnType<typeof authLoginCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: EmailTokenObtain },
    TContext
  >;
}): UseMutationResult<TData, TError, { data: EmailTokenObtain }, TContext> => {
  const mutationOptions = getAuthLoginCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const authRefreshCreate = (
  tokenRefresh: NonReadonly<TokenRefresh>,
  signal?: AbortSignal,
) => {
  return customAxios<TokenRefresh>({
    url: `/api/auth/refresh/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tokenRefresh,
    signal,
  });
};

export const getAuthRefreshCreateMutationOptions = <
  TData = Awaited<ReturnType<typeof authRefreshCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}) => {
  const mutationKey = ["authRefreshCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefreshCreate>>,
    { data: NonReadonly<TokenRefresh> }
  > = (props) => {
    const { data } = props ?? {};

    return authRefreshCreate(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
};

export type AuthRefreshCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefreshCreate>>
>;
export type AuthRefreshCreateMutationBody = NonReadonly<TokenRefresh>;
export type AuthRefreshCreateMutationError = unknown;

export const useAuthRefreshCreate = <
  TData = Awaited<ReturnType<typeof authRefreshCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}): UseMutationResult<
  TData,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationOptions = getAuthRefreshCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
export const authRegisterCreate = (
  userRegistration: UserRegistration,
  signal?: AbortSignal,
) => {
  return customAxios<UserRegistration>({
    url: `/api/auth/register/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userRegistration,
    signal,
  });
};

export const getAuthRegisterCreateMutationOptions = <
  TData = Awaited<ReturnType<typeof authRegisterCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: UserRegistration },
    TContext
  >;
}) => {
  const mutationKey = ["authRegisterCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegisterCreate>>,
    { data: UserRegistration }
  > = (props) => {
    const { data } = props ?? {};

    return authRegisterCreate(data);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: UserRegistration },
    TContext
  >;
};

export type AuthRegisterCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegisterCreate>>
>;
export type AuthRegisterCreateMutationBody = UserRegistration;
export type AuthRegisterCreateMutationError = unknown;

export const useAuthRegisterCreate = <
  TData = Awaited<ReturnType<typeof authRegisterCreate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { data: UserRegistration },
    TContext
  >;
}): UseMutationResult<TData, TError, { data: UserRegistration }, TContext> => {
  const mutationOptions = getAuthRegisterCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
